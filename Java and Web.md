## 1. Java의 특징?  
- 자바가상머신(JVM)만 설치하면 컴퓨터의 OS에 상관 없이 작동함.  
- 기본 자료형을 제외한 모든 요소들이 객체로 표현  
- 객체 지향 특징인 캡슐화, 상속, 다형성이 잘 적용.  
- Garbage Collector를 통한 자동적인 메모리 관리  
- 멀티 쓰레드 지원  

## 2. 객체지향 프로그래밍  
- 데이터를 객체로 취급하여 프로그램에 반영, 순차적으로 프로그램이 동작하는 C와 달리 객체와 객체의 상호작용을 통해 프로그램이 동작한다.  

### 2-1. 객체지향 언어 특징  
- 추상화 : 객체에서 공통된 속성과 행위를 추출하는 것을 추상화(Abstraction)라고 한다.
- 캡슐화 : 프로그램의 세부 구현을 외부로 드러나지 않도록 특정 모듈로 감추는 것이다.
- 상속 : 기존의 클래스를 재사용하여 새로운 클래스를 작성. 보다 적은 코드로 새로운 클래스를 작성할 수 있고 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 매우 용이하다.  
- 다형성 : 하나의 객체가 여러개의 자료형 타입을 가질 수 있는 것. (https://m.blog.naver.com/PostView.nhn?blogId=heartflow89&logNo=220979244668&proxyReferer=https:%2F%2Fwww.google.com%2F)  

## 3. Overloading Vs. Overriding  
- Overloading : 같은 이름의 메소드를 매개변수 타입을 다르게 하거나, 개수를 다르게 해 여러개 정의.  
- OVerriding : 상위 클래스의 메소드를 하위 클래스에서 재정의.  

## 4. 객체, 인스턴스, 클래스  
- 클래스 : 객체를 만들어 내기 위한 설계도 혹은 틀
- 객체 : 일반적으로 설계도인 클래스가 구체적인 실체인 인스턴스가 되었을 때 객체라고 부른다.  
- 인스턴스 : new 키워드를 이용해 클래스 변수에 메모리를 할당.  

## 5. Interface Vs. Abstact  
- 공통점 : new 연산자로 객체 생성 불가능. 사용하기 위해서는 하위 클래스에서 확장/구현 해야한다.  
- 차이점 : 추상 클래스는 메소드를 정의하고 구현할 수 있지만, 인터페이스는 선언만 가능. Interface는 다중상속이 가능하다.  

## 6. Garbage Collection  
- 시스템에서 더 이상 사용하지 않는 메모리를 찾아 사용 가능한 자원으로 회수하는 것. 가비지 컬렉션을 수행하는 부분을 가비지 컬렉터라고 한다.  

## 7. Primitive Type, Reference Type  
- Primitive Type : char, int, double, boolean 등  
- Reference Type : class, interface  
- primitive type을 객체로 다루기 위해 사용하는 Class를 Wrapper Class라고 한다.  
- Boxing : Primitive type -> Wrapper Class  
- UnBoxing : Wrapper Class -> Primitive Type  

## 8. Equals과 ==의 차이점  
- equals 메소드는 비교하고자 하는 대상의 Value를 비교하지만, == 연산자는 비교하고자 하는 대상의 Reference를 비교한다.  

## 9. Generics  
- 제네릭은 클래스, 메소드에서 사용할 데이터 타입을 인스턴스를 생성할 때나 메소드를 호출할 때 정하는 기법.  
- 제네릭을 사용하면 클래스 내부에서 사용하는 데이터의 타입을 지정할 수 있고, 타입을 잘못 사용하여 발생하는 에러를 최소화 할 수 있다.

![image](https://user-images.githubusercontent.com/32921115/111036023-7b94ac80-8460-11eb-822a-0a7065962a04.png)

## 10. Static 키워드 
- Static 키워드를 이용하여 선언한 변수를 '정적 변수'라고도 한다. 이 변수들은 해당 클래스의 모든 객체들에게 공유가 됨.  
- Static 메소드를 "정적 메소드"라고 한다. 객체가 생성되지 않는 상태에서 호출되는 메소드다.  
- Static이 붙은 키워ㄷ는 
### 10-1. Static을 사용할 때의 주의 사항  
- 멤버 변수 중 모든 인스턴스에서 공통으로 사용해야 하는 것에만 static 선언한다.    
- Static이 붙은 멤버 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.  
- Static 메소드에서는 인스턴스 변수를 사용할 수 없다.  
- 절대 변하지 않는 값을 final static으로 선언하면 가비지 컬렉션의 대상이 되지 않는다.  
- Static은 시스템의 심각한 오류의 원인이 될 수도 있다.  

## 11. Singleton Pattern  
- 클래스가 한 개의 인스턴스만을 만들 수 있도록 하고 (Static), 어디서나 생성된 인스턴스에 접근할 수 있도록 한다.    

![image](https://user-images.githubusercontent.com/32921115/111036695-d7ad0000-8463-11eb-9d12-5fd8d640e9e5.png)

- 장점 : 한번의 new로 인스턴스를 사용하기 때문에 메모리 낭비를 방지. 그리고 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움.  
- 단점 : 다른 클래스의 인스턴스 간에 결합도가 높아져 OCP 원칙을 위배함. 즉 수정이 어려워지고 테스트하기 어려워진다.  


## 12. 접근제한자(public > protected > default > private)

1. public - 접근 제한이 없다.(같은 프로젝트 내에 어디서든 사용가능)  
2. protected - 같은 패키지 내, 다른 패키지에서 상속받아 자식 클래스에서 접근 가능  
3. default - 같은 패키지 내에서만 접근 가능  
4. private - 같은 클래스 내에서만 접근 가능  

## 13. Web Server  
- 웹 서버 : 웹 브라우저와 같은 클라이언트로부터 HTTP 요청을 받아들이고, HTML 문서와 같은 웹 페이지를 반환하는 컴퓨터 프로그램.  
- 웹 서버 (하드웨어) : 위에 언급한 기능을 제공하는 컴퓨터 프로그램을 실행하는 컴퓨터  

## 14. HTTP?  
- World Wide Web에서 정보를 주고 받을 수 있는 프로토콜. 주로 HTML 문서를 주고 받고 80번 Port를 사용한다.   
- HTTP는 클라이언트와 서버 사이에 이루어지는 요청/응답(request/response) 프로토콜이다. 예를 들면, 클라이언트인 웹 브라우저가 HTTP를 통하여 서버로부터 웹페이지(HTML)나 그림 정보를 요청하면, 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달하게 된다. 이 정보가 모니터와 같은 출력 장치를 통해 사용자에게 나타나는 것이다.  

## 15. GET/POST  
- HTTP 통신할때 보내는 데이터는 HTTP 패킷이라 하는데 해당 패킷의 구조는 크게 Header 영역과 Body영역으로 나누어진다. Header에는 크게 여러가지 정보와 어떠한 방식의 메소드를 사용 하였는지에 대해 적게 된다. 또한 어떠한 메소드 방식을 사용하였는지에 따라 Body 영역의 사용 유무 및 사용 방법이 달라지게 된다.  
- HTTP 메시지의 시작 줄과 HTTP 헤더를 묶어서 요청 헤드(head)라고 부르며, 이와 반대로 HTTP 메시지의 페이로드는 본문(body)이라고 한다.  

![image](https://user-images.githubusercontent.com/32921115/111037782-07aad200-8469-11eb-8d51-c6ca22218d0c.png)

### 15-1. GET  
- GET 방식의 특징으로는 대표적으로 URL에 Parameter를 붙여서 전송한다는 것.  
- 주로 읽거나 검색할 때 사용됨.  
- 캐싱을 통해, 요청이 또 발생할 시 빠르게 접근한다.  
- idempotent하다. 즉, 같은 요청을 여러 번 하더라도 변함없이 항상 같은 응답을 받을 수 있다. 주로 조회를 할 때 사용되는 이유.

### 15-2. POST  
- URL에 붙여 보내지 않고 BODY에 데이터를 넣어서 보낸다. URL에 데이터의 내용이 눈에 보이지 않는다.  

- 데이터베이스에 대한 갱신 작업과 같은 서버측에서의 정보 갱신 작업을 원할 때 사용한다.  
- Non-idempotent하기 때문에 서버에게 동일한 요청을 여러 번 전송해도 응답은 항상 다를 수 있다. 이는 서버의 상태나 데이터를 변경시킬 때 사용되는 이유이다.  
- 게시글을 쓰면 서버에 게시글이 저장이 되고, 게시글을 삭제하면 해당 데이터가 없어지는 등 POST로 요청을 하게 되면 서버의 무언가는 변경되도록 사용된다. 이처럼 POST는 생성, 수정, 삭제에 사용할 수 있지만, 생성에는 POST, 수정은 PUT 또는 PATCH, 삭제는 DELETE가 더 용도에 맞는 메소드라고 할 수 있다.  

## 16. TCP/UDP  
- 클라이언트와 서버가 데이터를 주고 받을 수 있는 프로토콜. TCP는 3-handshaking을 통해 신뢰성 있는 전달을 하고, UDP는 Best-Effort 방식으로 데이터를 전달한다.  

![image](https://user-images.githubusercontent.com/32921115/111037090-f6ac9180-8465-11eb-9f23-e909b18384ad.png)

## 17. MVC Pattern  
- Model-View-Controller의 약자
- Model : 어플리케이션의 데이터를 관리하는 부분 또는 로직 (뷰의 모델은 한 개만 있음) ex) 처리되는 알고리즘, DB 와 상호작용(CRUD Create Read Update Delete), 데이터 등  
- View : 사용자가 보는 화면에 나타나는 부분을 관리 (모델에 대해서 뷰는 여러 개 있을 수 있음) ex) 사용자에게 “무엇”을 화면(UI)으로 보여줌
- Controller : 사용자의 입력을 처리하고, Model과 View 사이에서 상호 작용을 할 수 있도록 지원, 즉 사용자로부터의 입력을 받고 Model 또는 View의 중개인 역할을 담당. (모델에 대해서 뷰는 여러 개 있을 수 있음)  

![image](https://user-images.githubusercontent.com/32921115/111073935-25893d00-8524-11eb-995b-e6256ee8234e.png)

## 17-1. Web과 MVC Pattern  
1. 사용자가 웹사이트에 접속한다. (Uses)  
2. Controller는 사용자가 요청한 웹페이지를 서비스 하기 위해서 모델을 호출한다. (Manipulates)  
3. 모델은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후에 그 결과를 리턴한다.  
4. Controller는 Model이 리턴한 결과를 View에 반영한다. (Updates)  
5. 데이터가 반영된 VIew는 사용자에게 보여진다. (Sees)  

## 18. DAO Pattern  
- DB를 사용하는 방법이 변경되면 클라이언트의 수정이 많아져, 업무와 DBMS를 분리하기 위해 사용
- 업무와 데이터 2계층을 분리하고, 서로 그 상태를 동일하게 유지(persistence)  

## 19. Web Push & Pull based Approach  

### 19-1. Pull  
- 클라이언트가 서버에 요청을 보내고 응답을 받는 방식 (일반적인 형태), Active한 성격.  
- 장점 : HTTP 메세지를 사용해 구현이 가능, 서버는 HTTP의 Stateless 상태 유지 가능  
- 단점 : Consistency가 약함. 메세지 오버헤드가 높음.  

### 19-2. Push  
- 별도의 클라이언트의 요청 없이 서버에서 사용자에게 정보를 전달해주는 방식  
- 장점 : 클라이언트는 가만히 있어도 됨. Tight Consistency.  
- 단점 : Server는 클라이언트가 어떤 상태로 있는지 알아야 알림을 계속 보낼 수 있음. 즉 Stateless 특징을 가진 HTTP위에 State를 구현해야 한다.  

## 20. Cookie와 Session  
- 공통점 : HTTP의 Stateless한 특징을 보완하기 위해 사용.   
- 차이점 :  
- 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문.
- 가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용.  
- 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠르다. 그 이유는 세션은 서버의 처리가 필요하기 때문이다.  
- 보안, 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만, 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋음.  
- 라이프 사이클, 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다.  
- 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.  
- 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.  
